
.. _testing:

*************************************************************************
                                 Testing
*************************************************************************

This page explains how Boost.StaticViews tests work and shows some up to
date results. There are three kinds of tests. First, there are
:ref:`correctness` tests. These are just unit tests and are meant to
verify the correct behavior at both compile- and run-time. Then, there
are :ref:`optimisation` tests. They check how good modern compilers can
optimise Boost.StaticViews' code. Finally, there are :ref:`benchmarks`.
They check how long it takes to compile some tests, and how much memory
compilers use doing that.

.. note::
  It's questionable whether benchmarks are actually tests, but `Boost
  Library Requirements and Guidelines
  <http://www.boost.org/development/requirements.html#Organization>`_ don't
  have a specific place to put benchmarking results. Thus for simplicity,
  consider benchmarks being tests.



.. _correctness:

Correctness
===========

Unit tests are simple: write a test and add a corresponding
run/compile/link rule to the Jamfile. There's not much to explain.

**TODO** A nice table presenting the results.


.. _benchmarks:

Benchmarks
==========

Boost.StaticViews is meant to be used primary at compile-time. In this
section, we're
not interested in runtime performance, `optimisation` tests cover that. We
focus on compilation times and memory usage (during compilation).
Measuring compilation time is simple: start the timer, compiler the
program, stop the timer. 

Measuring memory usage is a bit more involved.
There's no platform independent way to check how much *physical* memory a
process uses at a certain time point. It it, however, relatively simple to
obtain the total physical memory used. On Linux, we can do the following:

.. code-block:: cpp

  struct sysinfo info;
  sysinfo(&info);
  auto const mem_unit   = static_cast<std::size_t>(info.mem_unit);
  auto const total_ram  = info.totalram  * mem_unit;
  auto const total_swap = info.totalswap * mem_unit;
  auto const avail_ram  = info.freeram  * mem_unit;
  auto const avail_swap = info.freeswap * mem_unit;

to get the total and available memory in bytes. On Windows

.. code-block:: cpp

  MEMORYSTATUS ms;
  std::memset(&ms, 0, sizeof(ms));
  ms.dwLength = sizeof(ms);
  GlobalMemoryStatus(&ms);

  std::size_t const total_ram  = ms.dwTotalPhys;
  std::size_t const total_swap = ms.dwTotalPageFile;
  std::size_t const avail_ram  = ms.dwAvailPhys;
  std::size_t const avail_swap = ms.dwAvailPageFile;

Both code snippets ignore the details like error handling, but should
still illustrate the point. For a more complete implementation, see
`measure_memory.cpp
<https://github.com/BoostGSoC17/static-views/blob/gh-pages/test/benchmarks/measure_memory.cpp>`_
file. 

Now that we have the means to get memory usage at a certain time point, we
can let one thread run the compilation command, while another one
measures memory usage as a function of time. Although we can only get the
*total* memory usage, on a relatively quiet machine one can usually see a
measurable bump in memory usage. Here's an example of compiling some code
with GCC:

.. image:: pictures/memory-time.png

It makes little sense to compile a single file. What we're really
interested in is how memory usage scales with input size. To accomplish
this, we define the data in an external file. For example

.. code-block:: cpp
  :dedent: 2

  static constexpr int random_array[] = {
  #   include "test_data.txt"
  };

where ``test_data.txt`` file gets generated by a Python script. So the
workflow is now: generate ``test_data.txt``, call ``b2`` and measure
memory usage, save results, repeat. The Jamfile determines the values
like ``<toolset>`` and calls the Python script with these parameters. This
allows the script to call back ``b2`` with correct configuration parameters and
also create different files on different platforms/compilers.

Next we present the results of some tests.

.. _test-sort:

Sort
""""

Sorts an array of integers at compile-time.

* ``GCC-6.3.0``:

  .. image:: ../test/benchmarks/results/sort.gcc-6.3.0.png

* ``GCC-7``:

  .. image:: ../test/benchmarks/results/sort.gcc-7.png

* ``Clang-3.8``:

  .. image:: ../test/benchmarks/results/sort.clang-3.8.png

* ``Clang-3.9``:

  .. image:: ../test/benchmarks/results/sort.clang-3.9.png

* ``Clang-4.0.0``:

  .. image:: ../test/benchmarks/results/sort.clang-4.0.0.png

* ``Clang-5.0.0``:

  .. image:: ../test/benchmarks/results/sort.clang-5.0.0.png

* ``Clang/C2``:

  .. image:: ../test/benchmarks/results/sort.clang-14.1.png



.. _optimisation:

Optimisation
============

**TODO** explain briefly how all the tools and scripts work.


.. _nested-drop:

Nested drop
"""""""""""

**TODO** add a short explanation of the test.

* ``GCC-6.3.0``:

  .. literalinclude:: ../test/optimisation/results/nested.gcc-6.3.0.xml
    :language: xml

* ``GCC-7``:

  .. literalinclude:: ../test/optimisation/results/nested.gcc-6.3.0.xml
    :language: xml

* ``Clang-3.8``:

  .. literalinclude:: ../test/optimisation/results/nested.clang-3.8.xml
    :language: xml

* ``Clang-3.9``:

  .. literalinclude:: ../test/optimisation/results/nested.clang-3.9.xml
    :language: xml

* ``Clang-4.0.0``:

  .. literalinclude:: ../test/optimisation/results/nested.clang-4.0.0.xml
    :language: xml

* ``Clang-5.0.0``:

  .. literalinclude:: ../test/optimisation/results/nested.clang-5.0.0.xml
    :language: xml

* ``MSVC-14.1``:

  .. literalinclude:: ../test/optimisation/results/nested.msvc-14.1.xml
    :language: xml
